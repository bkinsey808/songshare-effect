/**
 * ⚠️  GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by:
 * File: scripts/build/generate-effect-schemas/generate-effect-schemas.ts
 * Command: npm run supabase:generate
 *
 * Generated Effect-TS schemas from Supabase database types
 * Last generated: 2025-11-15T16:31:08.294Z
 *
 * To regenerate this file, run:
 * npm run supabase:generate
 *
 * Any manual changes to this file will be overwritten on next generation.
 */
import { Schema } from "effect";

// Common validation schemas
export const NonEmptyStringSchema: typeof Schema.NonEmptyString =
	Schema.NonEmptyString;
export const EmailSchema: Schema.Schema<string, string> = Schema.String.pipe(
	Schema.nonEmptyString(),
	Schema.pattern(/^[^\s@]+@[^\s@]+\.[^\s@]+$/),
);
export const UUIDSchema: typeof Schema.UUID = Schema.UUID;
export const PositiveNumberSchema: typeof Schema.Positive = Schema.Positive;
export const NonNegativeNumberSchema: typeof Schema.NonNegative =
	Schema.NonNegative;

// song table schemas
export const SongSchema: Schema.Struct<{
	created_at: typeof Schema.NonEmptyString;
	private_notes: typeof Schema.NonEmptyString;
	song_id: typeof Schema.UUID;
	updated_at: typeof Schema.NonEmptyString;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	created_at: Schema.NonEmptyString,
	private_notes: Schema.NonEmptyString,
	song_id: Schema.UUID,
	updated_at: Schema.NonEmptyString,
	user_id: Schema.UUID,
});

export type Song = Schema.Schema.Type<typeof SongSchema>;

export const SongInsertSchema: Schema.Struct<{
	private_notes: typeof Schema.NonEmptyString;
	song_id: Schema.optional<typeof Schema.UUID>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	private_notes: Schema.NonEmptyString,
	song_id: Schema.optional(Schema.UUID),
	user_id: Schema.optional(Schema.UUID),
});

export type SongInsert = Schema.Schema.Type<typeof SongInsertSchema>;

export const SongUpdateSchema: Schema.Struct<{
	private_notes: Schema.optional<typeof Schema.NonEmptyString>;
	song_id: Schema.optional<typeof Schema.UUID>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	private_notes: Schema.optional(Schema.NonEmptyString),
	song_id: Schema.optional(Schema.UUID),
	user_id: Schema.optional(Schema.UUID),
});

export type SongUpdate = Schema.Schema.Type<typeof SongUpdateSchema>;

// song_library table schemas
export const SongLibrarySchema: Schema.Struct<{
	created_at: typeof Schema.NonEmptyString;
	song_id: typeof Schema.UUID;
	song_owner_id: typeof Schema.UUID;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	created_at: Schema.NonEmptyString,
	song_id: Schema.UUID,
	song_owner_id: Schema.UUID,
	user_id: Schema.UUID,
});

export type SongLibrary = Schema.Schema.Type<typeof SongLibrarySchema>;

export const SongLibraryInsertSchema: Schema.Struct<{
	song_id: typeof Schema.UUID;
	song_owner_id: typeof Schema.UUID;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	song_id: Schema.UUID,
	song_owner_id: Schema.UUID,
	user_id: Schema.UUID,
});

export type SongLibraryInsert = Schema.Schema.Type<
	typeof SongLibraryInsertSchema
>;

export const SongLibraryUpdateSchema: Schema.Struct<{
	song_id: Schema.optional<typeof Schema.UUID>;
	song_owner_id: Schema.optional<typeof Schema.UUID>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	song_id: Schema.optional(Schema.UUID),
	song_owner_id: Schema.optional(Schema.UUID),
	user_id: Schema.optional(Schema.UUID),
});

export type SongLibraryUpdate = Schema.Schema.Type<
	typeof SongLibraryUpdateSchema
>;

// song_public table schemas
export const SongPublicSchema: Schema.Struct<{
	created_at: Schema.optional<typeof Schema.String>;
	fields: Schema.Array$<typeof Schema.String>;
	key: Schema.optional<typeof Schema.String>;
	long_credit: Schema.optional<typeof Schema.String>;
	public_notes: Schema.optional<typeof Schema.String>;
	scale: Schema.optional<typeof Schema.String>;
	short_credit: Schema.optional<typeof Schema.String>;
	slide_order: Schema.Array$<typeof Schema.String>;
	slides: typeof Schema.Unknown;
	song_id: typeof Schema.UUID;
	song_name: typeof Schema.NonEmptyString;
	song_slug: typeof Schema.NonEmptyString;
	updated_at: Schema.optional<typeof Schema.String>;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	created_at: Schema.optional(Schema.String),
	fields: Schema.Array(Schema.String),
	key: Schema.optional(Schema.String),
	long_credit: Schema.optional(Schema.String),
	public_notes: Schema.optional(Schema.String),
	scale: Schema.optional(Schema.String),
	short_credit: Schema.optional(Schema.String),
	slide_order: Schema.Array(Schema.String),
	slides: Schema.Unknown,
	song_id: Schema.UUID,
	song_name: Schema.NonEmptyString,
	song_slug: Schema.NonEmptyString,
	updated_at: Schema.optional(Schema.String),
	user_id: Schema.UUID,
});

export type SongPublic = Schema.Schema.Type<typeof SongPublicSchema>;

export const SongPublicInsertSchema: Schema.Struct<{
	fields: Schema.Array$<typeof Schema.String>;
	key: Schema.optional<typeof Schema.String>;
	long_credit: Schema.optional<typeof Schema.String>;
	public_notes: Schema.optional<typeof Schema.String>;
	scale: Schema.optional<typeof Schema.String>;
	short_credit: Schema.optional<typeof Schema.String>;
	slide_order: Schema.Array$<typeof Schema.String>;
	slides: typeof Schema.Unknown;
	song_id: typeof Schema.UUID;
	song_name: typeof Schema.NonEmptyString;
	song_slug: typeof Schema.NonEmptyString;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	fields: Schema.Array(Schema.String),
	key: Schema.optional(Schema.String),
	long_credit: Schema.optional(Schema.String),
	public_notes: Schema.optional(Schema.String),
	scale: Schema.optional(Schema.String),
	short_credit: Schema.optional(Schema.String),
	slide_order: Schema.Array(Schema.String),
	slides: Schema.Unknown,
	song_id: Schema.UUID,
	song_name: Schema.NonEmptyString,
	song_slug: Schema.NonEmptyString,
	user_id: Schema.UUID,
});

export type SongPublicInsert = Schema.Schema.Type<
	typeof SongPublicInsertSchema
>;

export const SongPublicUpdateSchema: Schema.Struct<{
	fields: Schema.optional<Schema.Array$<typeof Schema.String>>;
	key: Schema.optional<typeof Schema.String>;
	long_credit: Schema.optional<typeof Schema.String>;
	public_notes: Schema.optional<typeof Schema.String>;
	scale: Schema.optional<typeof Schema.String>;
	short_credit: Schema.optional<typeof Schema.String>;
	slide_order: Schema.optional<Schema.Array$<typeof Schema.String>>;
	slides: Schema.optional<typeof Schema.Unknown>;
	song_id: Schema.optional<typeof Schema.UUID>;
	song_name: Schema.optional<typeof Schema.NonEmptyString>;
	song_slug: Schema.optional<typeof Schema.NonEmptyString>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	fields: Schema.optional(Schema.Array(Schema.String)),
	key: Schema.optional(Schema.String),
	long_credit: Schema.optional(Schema.String),
	public_notes: Schema.optional(Schema.String),
	scale: Schema.optional(Schema.String),
	short_credit: Schema.optional(Schema.String),
	slide_order: Schema.optional(Schema.Array(Schema.String)),
	slides: Schema.optional(Schema.Unknown),
	song_id: Schema.optional(Schema.UUID),
	song_name: Schema.optional(Schema.NonEmptyString),
	song_slug: Schema.optional(Schema.NonEmptyString),
	user_id: Schema.optional(Schema.UUID),
});

export type SongPublicUpdate = Schema.Schema.Type<
	typeof SongPublicUpdateSchema
>;

// user table schemas
export const UserSchema: Schema.Struct<{
	created_at: typeof Schema.NonEmptyString;
	email: typeof EmailSchema;
	google_calendar_access: typeof Schema.NonEmptyString;
	google_calendar_refresh_token: Schema.optional<typeof Schema.String>;
	linked_providers: Schema.optional<Schema.Array$<typeof Schema.String>>;
	name: typeof Schema.NonEmptyString;
	role: typeof Schema.NonEmptyString;
	role_expires_at: Schema.optional<typeof Schema.String>;
	sub: Schema.optional<typeof Schema.String>;
	updated_at: typeof Schema.NonEmptyString;
	user_id: typeof Schema.UUID;
}> = Schema.Struct({
	created_at: Schema.NonEmptyString,
	email: EmailSchema,
	google_calendar_access: Schema.NonEmptyString,
	google_calendar_refresh_token: Schema.optional(Schema.String),
	linked_providers: Schema.optional(Schema.Array(Schema.String)),
	name: Schema.NonEmptyString,
	role: Schema.NonEmptyString,
	role_expires_at: Schema.optional(Schema.String),
	sub: Schema.optional(Schema.String),
	updated_at: Schema.NonEmptyString,
	user_id: Schema.UUID,
});

export type User = Schema.Schema.Type<typeof UserSchema>;

export const UserInsertSchema: Schema.Struct<{
	email: typeof EmailSchema;
	google_calendar_access: Schema.optional<typeof Schema.NonEmptyString>;
	google_calendar_refresh_token: Schema.optional<typeof Schema.String>;
	linked_providers: Schema.optional<Schema.Array$<typeof Schema.String>>;
	name: typeof Schema.NonEmptyString;
	role: Schema.optional<typeof Schema.NonEmptyString>;
	role_expires_at: Schema.optional<typeof Schema.String>;
	sub: Schema.optional<typeof Schema.String>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	email: EmailSchema,
	google_calendar_access: Schema.optional(Schema.NonEmptyString),
	google_calendar_refresh_token: Schema.optional(Schema.String),
	linked_providers: Schema.optional(Schema.Array(Schema.String)),
	name: Schema.NonEmptyString,
	role: Schema.optional(Schema.NonEmptyString),
	role_expires_at: Schema.optional(Schema.String),
	sub: Schema.optional(Schema.String),
	user_id: Schema.optional(Schema.UUID),
});

export type UserInsert = Schema.Schema.Type<typeof UserInsertSchema>;

export const UserUpdateSchema: Schema.Struct<{
	email: Schema.optional<typeof EmailSchema>;
	google_calendar_access: Schema.optional<typeof Schema.NonEmptyString>;
	google_calendar_refresh_token: Schema.optional<typeof Schema.String>;
	linked_providers: Schema.optional<Schema.Array$<typeof Schema.String>>;
	name: Schema.optional<typeof Schema.NonEmptyString>;
	role: Schema.optional<typeof Schema.NonEmptyString>;
	role_expires_at: Schema.optional<typeof Schema.String>;
	sub: Schema.optional<typeof Schema.String>;
	user_id: Schema.optional<typeof Schema.UUID>;
}> = Schema.Struct({
	email: Schema.optional(EmailSchema),
	google_calendar_access: Schema.optional(Schema.NonEmptyString),
	google_calendar_refresh_token: Schema.optional(Schema.String),
	linked_providers: Schema.optional(Schema.Array(Schema.String)),
	name: Schema.optional(Schema.NonEmptyString),
	role: Schema.optional(Schema.NonEmptyString),
	role_expires_at: Schema.optional(Schema.String),
	sub: Schema.optional(Schema.String),
	user_id: Schema.optional(Schema.UUID),
});

export type UserUpdate = Schema.Schema.Type<typeof UserUpdateSchema>;

// user_public table schemas
export const UserPublicSchema: Schema.Struct<{
	user_id: typeof Schema.UUID;
	username: typeof Schema.NonEmptyString;
}> = Schema.Struct({
	user_id: Schema.UUID,
	username: Schema.NonEmptyString,
});

export type UserPublic = Schema.Schema.Type<typeof UserPublicSchema>;

export const UserPublicInsertSchema: Schema.Struct<{
	user_id: typeof Schema.UUID;
	username: typeof Schema.NonEmptyString;
}> = Schema.Struct({
	user_id: Schema.UUID,
	username: Schema.NonEmptyString,
});

export type UserPublicInsert = Schema.Schema.Type<
	typeof UserPublicInsertSchema
>;

export const UserPublicUpdateSchema: Schema.Struct<{
	user_id: Schema.optional<typeof Schema.UUID>;
	username: Schema.optional<typeof Schema.NonEmptyString>;
}> = Schema.Struct({
	user_id: Schema.optional(Schema.UUID),
	username: Schema.optional(Schema.NonEmptyString),
});

export type UserPublicUpdate = Schema.Schema.Type<
	typeof UserPublicUpdateSchema
>;

// API Response schemas
const _ApiSuccessResponseSchemaImpl = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Struct<{
	success: Schema.Literal<[true]>;
	data: Schema.optional<Schema.Schema<A, I, R>>;
	message: Schema.optional<typeof Schema.String>;
}> =>
	Schema.Struct({
		success: Schema.Literal(true),
		data: Schema.optional(dataSchema),
		message: Schema.optional(Schema.String),
	});

const _ApiErrorResponseSchemaImpl: Schema.Struct<{
	success: Schema.Literal<[false]>;
	error: typeof Schema.String;
	message: Schema.optional<typeof Schema.String>;
}> = Schema.Struct({
	success: Schema.Literal(false),
	error: Schema.String,
	message: Schema.optional(Schema.String),
});

export const ApiSuccessResponseSchema = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Schema<
	Schema.Schema.Type<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>,
	Schema.Schema.Encoded<
		ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>
	>,
	Schema.Schema.Context<
		ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>
	>
> => _ApiSuccessResponseSchemaImpl(dataSchema);

export const ApiErrorResponseSchema: Schema.Schema<
	Schema.Schema.Type<typeof _ApiErrorResponseSchemaImpl>,
	Schema.Schema.Encoded<typeof _ApiErrorResponseSchemaImpl>
> = _ApiErrorResponseSchemaImpl;

export const ApiResponseSchema = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Schema<
	| Schema.Schema.Type<
			ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>
	  >
	| Schema.Schema.Type<typeof _ApiErrorResponseSchemaImpl>,
	| Schema.Schema.Encoded<
			ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>
	  >
	| Schema.Schema.Encoded<typeof _ApiErrorResponseSchemaImpl>,
	Schema.Schema.Context<
		ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>
	>
> => Schema.Union(ApiSuccessResponseSchema(dataSchema), ApiErrorResponseSchema);

export type ApiResponse<T> =
	| { success: true; data?: T; message?: string }
	| { success: false; error: string; message?: string };
