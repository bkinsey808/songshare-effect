# Realtime & RLS Architecture

## Overview

SongShare uses a **single Supabase auth user** (the "visitor" account) with dynamic `app_metadata` updates to support both anonymous visitors and authenticated users. This approach combines Supabase Realtime subscriptions with Row Level Security (RLS) for access control.

**Critical Requirement**: Supabase Realtime subscriptions **require authenticated JWT tokens**. Anonymous/unauthenticated connections cannot establish WebSocket subscriptions to database changes.

This architecture separates authentication from authorization:

1. **Authentication (Transport Layer)**: Single visitor Supabase auth account provides valid JWTs for Realtime connections
2. **Authorization (Access Control)**: RLS policies + JWT `app_metadata` determine what data each user can access

**Why not alternatives?**

- ❌ **Fully open database**: Realtime subscriptions require authentication
- ❌ **No auth/anonymous**: Cannot establish WebSocket connections
- ❌ **Individual Supabase auth users**: Unnecessary complexity managing two separate user systems

The single visitor account is essentially a **transport layer** enabling Realtime while RLS provides security.

## Key Concept: One Auth User, Many Application Users

```
┌─────────────────────────────────────────────────────┐
│ Supabase Auth                                       │
│                                                     │
│  Single "visitor" user account                     │
│  ├─ Email: visitor@yourdomain.com                  │
│  └─ app_metadata: { ... }  ← Updated per request   │
└─────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────┐
│ Application Users (Database Only)                  │
│                                                     │
│  ├─ user table (private data)                      │
│  └─ user_public table (public profiles)            │
└─────────────────────────────────────────────────────┘
```

**Why this approach?**

- **Realtime requires authenticated JWTs**: Supabase Realtime WebSocket connections cannot work with anonymous/unauthenticated clients
- **Single auth user = transport layer**: Provides valid Supabase-signed tokens for Realtime
- **RLS = access control**: Database policies check `app_metadata` to determine what each user can see
- **No need for individual auth users**: App manages users separately; RLS distinguishes them via metadata
- **Simpler than dual user systems**: Avoid syncing between Supabase auth users and app users
- RLS policies can distinguish users via JWT `app_metadata` claims

## Token Structure

### Visitor Token (Anonymous Access)

**Generated by:** `api/src/supabase/getSupabaseClientToken.ts`

**Process:**

1. Sign in to Supabase as visitor user
2. Check if `app_metadata.visitor_id` exists
3. If missing, update metadata: `{ visitor_id: "uuid" }`
4. Sign in again to get fresh JWT with metadata
5. Return `access_token`

**JWT Claims:**

```json
{
  "sub": "visitor-user-uuid",
  "aud": "authenticated",
  "role": "authenticated",
  "app_metadata": {
    "visitor_id": "visitor-user-uuid"
  }
}
```

**Access Rights:**

- ✅ Read from `*_public` tables
- ❌ No access to private tables
- ❌ No write access

### User Token (Authenticated Access)

**Generated by:** `api/src/user-session/getUserToken.ts`

**Process:**

1. Verify user session (from session JWT cookie)
2. Sign in to Supabase as visitor user
3. Update `app_metadata` to include user ID: `{ user: { user_id: "app-user-uuid" } }`
4. Sign in again to get fresh JWT with user metadata
5. Return `access_token`

**JWT Claims:**

```json
{
  "sub": "visitor-user-uuid",
  "aud": "authenticated",
  "role": "authenticated",
  "app_metadata": {
    "visitor_id": "visitor-user-uuid",
    "user": {
      "user_id": "app-user-uuid"
    }
  }
}
```

**Access Rights:**

- ✅ Read from `*_public` tables
- ✅ CRUD own records in private tables
- ✅ Realtime subscriptions with user context

## Row Level Security (RLS) Policies

### Public Table Access (Anyone can read)

```sql
-- Example: song_public table
CREATE POLICY "song_public_access"
ON song_public
FOR SELECT
TO authenticated
USING (
  -- Visitor token access
  (auth.jwt() -> 'app_metadata' ->> 'visitor_id') IS NOT NULL
  OR
  -- User token access
  (auth.jwt() -> 'app_metadata' -> 'user' ->> 'user_id') IS NOT NULL
);
```

**How it works:**

- Checks if JWT has either `visitor_id` OR `user.user_id` in `app_metadata`
- Both visitor and user tokens satisfy this condition
- Everyone can read public data

### Private Table Access (Own data only)

```sql
-- Example: song table (private song data)
CREATE POLICY "song_private_access"
ON song
FOR SELECT
TO authenticated
USING (
  user_id = ((auth.jwt() -> 'app_metadata' -> 'user' ->> 'user_id'))::uuid
);

CREATE POLICY "song_insert"
ON song
FOR INSERT
TO authenticated
WITH CHECK (
  user_id = ((auth.jwt() -> 'app_metadata' -> 'user' ->> 'user_id'))::uuid
);
```

**How it works:**

- Extracts `user_id` from JWT's `app_metadata.user.user_id`
- Only matches records where table's `user_id` equals JWT claim
- Visitor tokens have no `user` metadata → no access
- User tokens only access their own data

### User-Specific Data (song_library example)

```sql
CREATE POLICY "song_library_access"
ON song_library
FOR SELECT
TO authenticated
USING (
  user_id = ((auth.jwt() -> 'app_metadata' -> 'user' ->> 'user_id'))::uuid
);
```

**How it works:**

- User's library is private to them
- Only authenticated users see their own library entries
- Visitors cannot access any library data

## Realtime Subscriptions

### Client-Side Implementation

**Example:** `react/src/pages/UserPublicSubscriptionPage.tsx`

```typescript
// 1. Get authenticated client (automatically uses correct token)
const supabase = await getSupabaseClientWithAuth();

// 2. Create Realtime channel
const channel = supabase
  .channel(`user_public_changes_${Date.now()}`)
  .on('postgres_changes', {
    event: 'INSERT',
    schema: 'public',
    table: 'user_public'
  }, (payload) => {
    // Handle insert
  })
  .subscribe();
```

**Token Selection:**

- `getSupabaseClientWithAuth()` calls `getSupabaseAuthToken()`
- If user signed in → fetch USER token from `/api/auth/user/token`
- If user signed out → fetch VISITOR token from `/api/auth/visitor`
- Token cached in memory until expiry

### Realtime with RLS

**Supabase Realtime behavior:**

1. Client connects to Realtime WebSocket with JWT
2. Client subscribes to table changes
3. Server executes RLS policies on incoming change events
4. Only changes passing RLS are sent to client

**Example scenarios:**

**Visitor subscribing to `user_public`:**

```typescript
// Visitor JWT has: { app_metadata: { visitor_id: "..." } }
// RLS allows SELECT if visitor_id OR user.user_id exists
// ✅ Visitor receives all INSERT/UPDATE/DELETE events
```

**User subscribing to `song_library`:**

```typescript
// User JWT has: { app_metadata: { user: { user_id: "user-123" } } }
// RLS filters: user_id = JWT's user.user_id
// ✅ User only receives events for their own library entries
```

## Security Model

### Access Control Matrix

| User State             | Public Tables (`*_public`)            | Private Tables (`song`, `user`) | User-Specific (`song_library`) |
| ---------------------- | ------------------------------------- | ------------------------------- | ------------------------------ |
| **Visitor**            | ✅ Read all                           | ❌ No access                    | ❌ No access                   |
| **Authenticated User** | ✅ Read all<br/>✅ Create own records | ✅ CRUD own records only        | ✅ CRUD own records only       |

### Token Security

**Client-Side:**

- Tokens stored in memory (not localStorage or cookies)
- Automatic cleanup on expiry
- No sensitive data exposure to client JavaScript

**Server-Side:**

- Service key operations isolated from client
- Token generation behind authentication
- Session verification required for user tokens

**Network:**

- HTTPS required for production
- Tokens transmitted in Authorization headers
- 1-hour token lifetime with automatic refresh

## Performance Optimizations

### Token Caching

**Server-Side:**

```typescript
// In getSupabaseClientToken.ts
const cached = getCachedClientToken();
if (cached.token && now < cached.expiry - TOKEN_CACHE_SKEW_SECONDS) {
  return cached.token; // Reuse until expiry
}
```

**Client-Side:**

```typescript
// In getSupabaseClient.ts
const clients = getGlobalClientCache();
if (clients.has(supabaseClientToken)) {
  return clients.get(supabaseClientToken); // Reuse client
}
```

### Minimizing Auth Operations

**Visitor tokens:**

- Generated once per hour
- Shared across all anonymous users
- Cached server-side

**User tokens:**

- Generated per user session
- Cached in memory on client
- Refreshed only when expired

### RLS Query Optimization

**Indexed columns:**

```sql
CREATE INDEX idx_song_user_id ON song(user_id);
CREATE INDEX idx_song_library_user_id ON song_library(user_id);
```

**Policy design:**

- Simple UUID comparisons
- No complex joins in policies
- Database-level filtering (faster than app-level)

## Implementation Files

### Server-Side Token Generation

**Visitor Token:**

- `api/src/supabase/getSupabaseClientToken.ts`
- Endpoint: `GET /api/auth/visitor`

**User Token:**

- `api/src/user-session/getUserToken.ts`
- Endpoint: `GET /api/auth/user/token`
- Requires valid session cookie

### Client-Side Token Management

**Token Fetching:**

- `react/src/supabase/getSupabaseAuthToken.ts`
- Automatic selection between visitor/user tokens

**Client Creation:**

- `react/src/supabase/supabaseClient.ts`
- `getSupabaseClientWithAuth()` - Automatic token handling
- `getSupabaseClient(token)` - Manual token specification

### Example Components

**Working Examples:**

- `react/src/pages/UserPublicSubscriptionPage.tsx` - Realtime subscription to public table
- `react/src/pages/SongLibraryPage.tsx` - User-specific data with Realtime

## Troubleshooting

### Common Issues

**"JwtSignatureError: Failed to validate JWT signature"**

- **Cause:** JWT not signed by Supabase
- **Solution:** Use visitor account sign-in approach (this project's method)
- **Wrong approach:** Manually signing JWTs without Supabase's secret

**"No suitable key or wrong key type" (PGRST301)**

- **Cause:** JWT missing required metadata for RLS
- **Solution:** Ensure `app_metadata.user.user_id` is set
- **Check:** Verify metadata update and re-sign flow

**Realtime not receiving events**

- **Cause:** RLS blocking events
- **Debug:** Check JWT claims match RLS policy conditions
- **Test:** Query table directly with same token

**"User not found" in token generation**

- **Cause:** Trying to use getUserById with database user_id
- **Solution:** Use visitor account with metadata updates

### Debugging Tools

**Inspect JWT Claims:**

```typescript
// Decode token (use jwt.io or library)
const decoded = JSON.parse(atob(token.split('.')[1]));
console.log('app_metadata:', decoded.app_metadata);
```

**Test RLS Policies:**

```sql
-- In Supabase SQL Editor
SET request.jwt.claims = '{"app_metadata":{"user":{"user_id":"..."}}}'::json;
SELECT * FROM song_library; -- Should only return user's entries
```

**Monitor Realtime:**

```typescript
client.realtime.setAuth(token); // Explicitly set token
channel.on('system', (payload) => {
  console.log('Channel status:', payload);
});
```

## Best Practices

### When to Use This Pattern

**Use when you need:**

- ✅ Realtime subscriptions for both authenticated and anonymous users
- ✅ RLS-based access control without managing individual auth users
- ✅ Simple token management with automatic switching
- ✅ Support for both public and private data
- ✅ Your app manages user accounts separately from Supabase auth

**Critical requirement satisfied:**

- ✅ **Realtime subscriptions work**: Requires authenticated Supabase JWTs (cannot work with anonymous access)
- ✅ **Access control via RLS**: Checks `app_metadata` in JWT claims for authorization
- ✅ **No dual user systems**: No need to create/manage Supabase auth users for every app user
- ✅ **WebSocket connections**: Visitor account provides valid JWT for establishing connections

**Don't use when:**

- ❌ You need Supabase's built-in auth features (password reset, email verification)
- ❌ You want user-specific auth metadata managed by Supabase
- ❌ You need fine-grained role-based access beyond user/visitor distinction
- ❌ **You don't need Realtime subscriptions** (could use simpler anon key approach)

### Security Considerations

1. **Protect visitor credentials**
   - Store in server environment variables
   - Never expose in client code
   - Rotate periodically

2. **Validate session JWTs**
   - Always verify session before generating user tokens
   - Use secure JWT secrets
   - Implement token expiry

3. **Design RLS carefully**
   - Test policies thoroughly
   - Use UUID comparisons (not string matching)
   - Avoid complex policy logic

4. **Monitor token usage**
   - Log token generation events
   - Track failed auth attempts
   - Set up alerts for anomalies

## Migration Path

### From Traditional Supabase Auth

If migrating from individual Supabase auth users:

1. **Keep existing users** for backward compatibility
2. **Add metadata** to existing user accounts
3. **Update RLS policies** to check metadata first, fall back to user ID
4. **Gradually migrate** users to shared auth model
5. **Remove old policies** once migration complete

### Adding This to New Projects

1. **Create visitor Supabase auth user**
2. **Set environment variables** (email, password)
3. **Implement token endpoints** (visitor + user)
4. **Create RLS policies** with metadata checks
5. **Use getSupabaseClientWithAuth()** in components

---

This architecture provides a scalable, secure foundation for applications requiring both anonymous and authenticated access with Realtime capabilities, while maintaining the simplicity of a single Supabase auth user.
