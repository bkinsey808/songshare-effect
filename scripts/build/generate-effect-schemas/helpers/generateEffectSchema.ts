import { type TableDefinition } from "./generate-effect-schemas-types";
import { getEffectType } from "./getEffectType";
import { getTypeAnnotation } from "./getTypeAnnotation";
import { toPascalCase } from "./toPascalCase";

export function generateEffectSchema(table: Readonly<TableDefinition>): string {
	const NO_ITEMS = 0;
	const MAX_LINE_LENGTH = 80;
	const schemaName = `${toPascalCase(table.name)}Schema`;
	const typeName = toPascalCase(table.name);

	let output = `// ${table.name} table schemas\n`;

	output += `export const ${schemaName}: Schema.Struct<{\n`;

	table.columns.forEach((column) => {
		const baseSchema = getEffectType(column);
		const baseTypeAnnotation = getTypeAnnotation(baseSchema);
		let typeAnnotation = baseTypeAnnotation;

		if (column.nullable) {
			typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
		}

		output += `\t${column.name}: ${typeAnnotation};\n`;
	});

	output += "}> = Schema.Struct({\n";

	table.columns.forEach((column) => {
		let fieldSchema = getEffectType(column);

		if (column.nullable) {
			fieldSchema = `Schema.optional(${fieldSchema})`;
		}

		output += `\t${column.name}: ${fieldSchema},\n`;
	});

	output += "});\n\n";
	output += `export type ${typeName} = Schema.Schema.Type<typeof ${schemaName}>;\n\n`;

	const autoGeneratedFields = ["id", "created_at", "updated_at"];
	const insertColumns = table.columns.filter(
		(col) => !autoGeneratedFields.includes(col.name),
	);

	if (insertColumns.length > NO_ITEMS) {
		const insertSchemaName = `${typeName}InsertSchema`;
		output += `export const ${insertSchemaName}: Schema.Struct<{\n`;

		insertColumns.forEach((column) => {
			const baseSchema = getEffectType(column);
			const baseTypeAnnotation = getTypeAnnotation(baseSchema);
			let typeAnnotation = baseTypeAnnotation;

			if (column.isRequiredForInsert !== true || column.nullable) {
				typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
			}

			output += `\t${column.name}: ${typeAnnotation};\n`;
		});

		output += "}> = Schema.Struct({\n";

		insertColumns.forEach((column) => {
			let fieldSchema = getEffectType(column);

			if (column.isRequiredForInsert !== true || column.nullable) {
				fieldSchema = `Schema.optional(${fieldSchema})`;
			}

			output += `\t${column.name}: ${fieldSchema},\n`;
		});

		output += "});\n\n";
		const insertTypeLine = `export type ${typeName}Insert = Schema.Schema.Type<typeof ${insertSchemaName}>;`;
		if (insertTypeLine.length > MAX_LINE_LENGTH) {
			output += `export type ${typeName}Insert = Schema.Schema.Type<\n\ttypeof ${insertSchemaName}\n>;\n\n`;
		} else {
			output += `${insertTypeLine}\n\n`;
		}
	}

	const updateSchemaName = `${typeName}UpdateSchema`;
	output += `export const ${updateSchemaName}: Schema.Struct<{\n`;

	table.columns.forEach((column) => {
		if (autoGeneratedFields.includes(column.name) && column.name !== "id") {
			return;
		}

		const baseSchema = getEffectType(column);
		const baseTypeAnnotation = getTypeAnnotation(baseSchema);
		let typeAnnotation = baseTypeAnnotation;

		if (column.name !== "id") {
			typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
		}

		output += `\t${column.name}: ${typeAnnotation};\n`;
	});

	output += "}> = Schema.Struct({\n";

	table.columns.forEach((column) => {
		if (autoGeneratedFields.includes(column.name) && column.name !== "id") {
			return;
		}

		let fieldSchema = getEffectType(column);

		if (column.name !== "id") {
			fieldSchema = `Schema.optional(${fieldSchema})`;
		}

		output += `\t${column.name}: ${fieldSchema},\n`;
	});

	output += "});\n\n";
	const updateTypeLine = `export type ${typeName}Update = Schema.Schema.Type<typeof ${updateSchemaName}>;`;
	if (updateTypeLine.length > MAX_LINE_LENGTH) {
		output += `export type ${typeName}Update = Schema.Schema.Type<\n\ttypeof ${updateSchemaName}\n>;\n`;
	} else {
		output += `${updateTypeLine}\n`;
	}

	return output;
}
