import { type TableDefinition } from "./generate-effect-schemas-types";
import getEffectType from "./getEffectType";
import getTypeAnnotation from "./getTypeAnnotation";
import toPascalCase from "./toPascalCase";

export default function generateEffectSchema(table: Readonly<TableDefinition>): string {
	const NO_ITEMS = 0;
	const MAX_LINE_LENGTH = 80;
	const schemaName = `${toPascalCase(table.name)}Schema`;
	const typeName = toPascalCase(table.name);

	let output = `// ${table.name} table schemas\n`;

	output += `export const ${schemaName}: Schema.Struct<{\n`;

	for (const column of table.columns) {
		const baseSchema = getEffectType(column);
		const baseTypeAnnotation = getTypeAnnotation(baseSchema);
		let typeAnnotation = baseTypeAnnotation;

		if (column.nullable) {
			typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
		}

		output += `\t${column.name}: ${typeAnnotation};\n`;
	}

	output += "}> = Schema.Struct({\n";

	for (const column of table.columns) {
		let fieldSchema = getEffectType(column);

		if (column.nullable) {
			fieldSchema = `Schema.optional(${fieldSchema})`;
		}

		output += `\t${column.name}: ${fieldSchema},\n`;
	}

	output += "});\n\n";
	output += `export type ${typeName} = Schema.Schema.Type<typeof ${schemaName}>;\n\n`;

	const autoGeneratedFields = new Set(["id", "created_at", "updated_at"]);
	const insertColumns = table.columns.filter((col) => !autoGeneratedFields.has(col.name));

	if (insertColumns.length > NO_ITEMS) {
		const insertSchemaName = `${typeName}InsertSchema`;
		output += `export const ${insertSchemaName}: Schema.Struct<{\n`;

		for (const column of insertColumns) {
			const baseSchema = getEffectType(column);
			const baseTypeAnnotation = getTypeAnnotation(baseSchema);
			let typeAnnotation = baseTypeAnnotation;

			if (column.isRequiredForInsert !== true || column.nullable) {
				typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
			}

			output += `\t${column.name}: ${typeAnnotation};\n`;
		}

				  output += "}> = Schema.Struct({\n";

		for (const column of insertColumns) {
			let fieldSchema = getEffectType(column);

			if (column.isRequiredForInsert !== true || column.nullable) {
				fieldSchema = `Schema.optional(${fieldSchema})`;
			}

			output += `\t${column.name}: ${fieldSchema},\n`;
		}

		output += "});\n\n";
		const insertTypeLine = `export type ${typeName}Insert = Schema.Schema.Type<typeof ${insertSchemaName}>;`;
		if (insertTypeLine.length > MAX_LINE_LENGTH) {
			output += `export type ${typeName}Insert = Schema.Schema.Type<\n\ttypeof ${insertSchemaName}\n>;\n\n`;
		} else {
			output += `${insertTypeLine}\n\n`;
		}
	}

	const updateSchemaName = `${typeName}UpdateSchema`;
	output += `export const ${updateSchemaName}: Schema.Struct<{\n`;

	for (const column of table.columns) {
		if (autoGeneratedFields.has(column.name) && column.name !== "id") {
			// skip auto-generated, non-id fields
		} else {
			const baseSchema = getEffectType(column);
			const baseTypeAnnotation = getTypeAnnotation(baseSchema);
			let typeAnnotation = baseTypeAnnotation;

			if (column.name !== "id") {
				typeAnnotation = `Schema.optional<${baseTypeAnnotation}>`;
			}

			output += `\t${column.name}: ${typeAnnotation};\n`;
		}
	}

	output += "}> = Schema.Struct({\n";

	for (const column of table.columns) {
		if (autoGeneratedFields.has(column.name) && column.name !== "id") {
			// skip auto-generated, non-id fields
		} else {
			let fieldSchema = getEffectType(column);

			if (column.name !== "id") {
				fieldSchema = `Schema.optional(${fieldSchema})`;
			}

			output += `\t${column.name}: ${fieldSchema},\n`;
		}
	}

	output += "});\n\n";
	const updateTypeLine = `export type ${typeName}Update = Schema.Schema.Type<typeof ${updateSchemaName}>;`;
	if (updateTypeLine.length > MAX_LINE_LENGTH) {
		output += `export type ${typeName}Update = Schema.Schema.Type<\n\ttypeof ${updateSchemaName}\n>;\n`;
	} else {
		output += `${updateTypeLine}\n`;
	}

	return output;
}
