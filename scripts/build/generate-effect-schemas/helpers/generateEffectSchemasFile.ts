import { existsSync, mkdirSync, writeFileSync } from "fs";
import { dirname } from "path";

import { warn as sWarn } from "../../../utils/scriptLogger";
import { type TableDefinition } from "./generate-effect-schemas-types";
import { generateEffectSchema } from "./generateEffectSchema";

export function generateEffectSchemasFile(
	tables: TableDefinition[],
	outputPath: string,
): void {
	let fileContent = `/**
 * ⚠️  GENERATED FILE - DO NOT EDIT DIRECTLY
 * 
 * This file was automatically generated by:
 * File: scripts/build/generate-effect-schemas/generate-effect-schemas.ts
 * Command: npm run supabase:generate
 * 
 * Generated Effect-TS schemas from Supabase database types
 * Last generated: ${new Date().toISOString()}
 * 
 * To regenerate this file, run:
 * npm run supabase:generate
 * 
 * Any manual changes to this file will be overwritten on next generation.
 */
import { Schema } from "effect";
`;

	fileContent += `
// Common validation schemas
export const NonEmptyStringSchema: typeof Schema.NonEmptyString = Schema.NonEmptyString;
export const EmailSchema: Schema.Schema<string> = Schema.String.pipe(
	Schema.nonEmptyString(),
	Schema.pattern(/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/),
);
export const UUIDSchema: typeof Schema.UUID = Schema.UUID;
export const PositiveNumberSchema: typeof Schema.Positive = Schema.Positive;
export const NonNegativeNumberSchema: typeof Schema.NonNegative =
	Schema.NonNegative;

`;

	const START_INDEX = 0;
	tables.forEach((table, index) => {
		if (index > START_INDEX) {
			fileContent += "\n";
		}
		fileContent += generateEffectSchema(table);
	});

	fileContent += `
// API Response schemas
const _ApiSuccessResponseSchemaImpl = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Struct<{
	success: Schema.Literal<[true]>;
	data: Schema.optional<Schema.Schema<A, I, R>>;
	message: Schema.optional<typeof Schema.String>;
}> =>
	Schema.Struct({
		success: Schema.Literal(true),
		data: Schema.optional(dataSchema),
		message: Schema.optional(Schema.String),
	});

const _ApiErrorResponseSchemaImpl: Schema.Struct<{
	success: Schema.Literal<[false]>;
	error: typeof Schema.String;
	message: Schema.optional<typeof Schema.String>;
}> = Schema.Struct({
	success: Schema.Literal(false),
	error: Schema.String,
	message: Schema.optional(Schema.String),
});

export const ApiSuccessResponseSchema = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Schema<
	Schema.Schema.Type<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>,
	Schema.Schema.Encoded<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>,
	Schema.Schema.Context<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>
> => _ApiSuccessResponseSchemaImpl(dataSchema);

export const ApiErrorResponseSchema: Schema.Schema<
	Schema.Schema.Type<typeof _ApiErrorResponseSchemaImpl>,
	Schema.Schema.Encoded<typeof _ApiErrorResponseSchemaImpl>,
	Schema.Schema.Context<typeof _ApiErrorResponseSchemaImpl>
> = _ApiErrorResponseSchemaImpl;

export const ApiResponseSchema = <A, I, R>(
	dataSchema: Schema.Schema<A, I, R>,
): Schema.Schema<
	| Schema.Schema.Type<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>
	| Schema.Schema.Type<typeof _ApiErrorResponseSchemaImpl>,
	| Schema.Schema.Encoded<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>
	| Schema.Schema.Encoded<typeof _ApiErrorResponseSchemaImpl>,
	| Schema.Schema.Context<ReturnType<typeof _ApiSuccessResponseSchemaImpl<A, I, R>>>
	| Schema.Schema.Context<typeof _ApiErrorResponseSchemaImpl>
> => Schema.Union(ApiSuccessResponseSchema(dataSchema), ApiErrorResponseSchema);

export type ApiResponse<T> =
	| { success: true; data?: T; message?: string }
	| { success: false; error: string; message?: string };
`;

	const outputDir = dirname(outputPath);
	if (!existsSync(outputDir)) {
		mkdirSync(outputDir, { recursive: true });
	}

	writeFileSync(outputPath, fileContent, "utf-8");
	sWarn(`✅ Generated Effect schemas at: ${outputPath}`);
}
